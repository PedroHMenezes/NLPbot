{"Introduction": {"text": "If you think quantum mechanics sounds challenging, you are not alone. All of our intuitions are based on day-to-day experiences, and so are better at understanding the behavior of balls and bananas than atoms or electrons. Though quantum objects can seem random and chaotic at first, they just follow a different set of rules. Once we know what those rules are, we can use them to create new and powerful technology. Quantum computing will be the most revolutionary example of this.\nTo get you started on your journey towards quantum computing, let's test what you already know.\nWhich of the following is the correct description of a bit?\nActually, they are all correct: it's a very multi-purpose word! But if you chose \"the smallest unit of information\", it shows that you are already thinking along the right lines. The idea that information can be stored and processed as a series of 0s and 1s is quite a big conceptual hurdle, but it's something most people today know without even thinking about it. Taking this as a starting point, we can start to imagine bits that obey the rules of quantum mechanics. These quantum bits, or qubits, will then allow us to process information in new and different ways.\nWe'll start diving deeper into the world of qubits. For this, we'll need some way of keeping track of what they are doing when we apply gates. The most powerful way to do this is to use the mathematical language of vectors and matrices.\nThis chapter will be most effective for readers who are already familiar with vectors and matrices. Those who aren't familiar will likely be fine too, though it might be useful to consult our Introduction to Linear Algebra for Quantum Computing from time to time.\nSince we will be using Qiskit, our Python-based framework for quantum computing, it would also be useful to know the basics of Python. Those who need a primer can consult the Introduction to Python and Jupyter notebooks.", "links": ["https://learn.qiskit.org/course/ch-states/introduction#representing-30-19", " https://learn.qiskit.org/course/ch-states/introduction", " https://learn.qiskit.org/course/ch-states/introduction#introduction-3-3", "https://en.wikipedia.org/course/ch-states/the-atoms-of-computation", "https://en.wikipedia.org/course/ch-states/the-atoms-of-computation", "https://en.wikipedia.org/course/ch-states/representing-qubit-states", "https://en.wikipedia.org/course/ch-states/representing-qubit-states", "https://en.wikipedia.org/course/ch-states/single-qubit-gates", "https://en.wikipedia.org/course/ch-states/single-qubit-gates", "https://en.wikipedia.org/course/ch-states/the-case-for-quantum-computers", "https://en.wikipedia.org/course/ch-states/the-case-for-quantum-computers", "javascript:void(0)", "https://qiskit.org/learn", "javascript:void(0)", "https://en.wikipedia.org/v1/course/ch-states", "https://en.wikipedia.org/course/ch-appendix/an-introduction-to-linear-algebra-for-quantum-computing", "https://en.wikipedia.org/course/ch-prerequisites/introduction-to-python-and-jupyter-notebooks"]}, "Representing Qubit States": {"text": "You now know something about bits, and about how our familiar digital computers work. All the complex variables, objects and data structures used in modern software are basically all just big piles of bits. Those of us who work on quantum computing call these classical variables. The computers that use them, like the one you are using to read this article, we call classical computers.\nIn quantum computers, our basic variable is the qubit: a quantum variant of the bit. These have exactly the same restrictions as normal bits do: they can store only a single binary piece of information, and can only ever give us an output of 0 or 1-1 or 101-1. However, they can also be manipulated in ways that can only be described by quantum mechanics. This gives us new gates to play with, allowing us to find new ways to design algorithms.\nTo fully understand these new gates, we first need to understand how to write down qubit states. For this we will use the mathematics of vectors, matrices, and complex numbers. Though we will introduce these concepts as we go, it would be best if you are comfortable with them already. If you need a more in-depth explanation or a refresher, you can find the guide here.\nIn quantum physics we use statevectors to describe the state of our system. Say we wanted to describe the position of a car along a track, this is a classical system so we could use a number x:\n\\begin{align*} x=4 \\end{align*}\nAlternatively, we could instead use a collection of numbers in a vector called a statevector. Each element in the statevector contains the probability of finding the car in a certain place:\n\\begin{align*} \\cssId{x_ket}{|x\\rangle} = \\cssId{vector}{\\begin{bmatrix} 0 \\\\ \\vdots \\\\ 0 \\\\ 1 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{bmatrix}} \\begin{matrix} \\\\ \\\\ \\\\ \\leftarrow \\\\ \\\\ \\\\ \\\\ \\end{matrix} \\begin{matrix} \\\\ \\\\ \\text{Probability of} \\\\ \\text{car being at} \\\\ \\text{position 4} \\\\ \\\\ \\\\ \\end{matrix} \\end{align*}\nThis isn\u2019t limited to position, we could also keep a statevector of all the possible speeds the car could have, and all the possible colours the car could be. With classical systems (like the car example above), this is a silly thing to do as it requires keeping huge vectors when we only really need one number. But as we will see in this chapter, statevectors happen to be a very good way of keeping track of quantum systems, including quantum computers.\nClassical bits are always either 0 or 1 at every point during a computation. There is no more detail we can add to the state of a bit than this. So to write down the state of a of classical bit (c), we can just use these two binary values. For example:\n\\begin{align*} c = 0 \\end{align*}\nThis restriction is lifted for quantum bits. Whether we get a 0 or a 1 from a qubit only needs to be well-defined when a measurement is made to extract an output. At that point, it must commit to one of these two options. At all other times, its state will be something more complex than can be captured by a simple binary value.\nTo see how to describe these, we can first focus on the two simplest cases. As we saw in the last section, it is possible to prepare a qubit in a state for which it definitely gives the outcome 0 when measured.\nWe need a name for this state. Let's be unimaginative and call it 0 . Similarly, there exists a qubit state that is certain to output a 1. We'll call this 1. These two states are completely mutually exclusiveinclusive. Either the qubit definitely outputs a 0, or it definitely outputs a 1. There is no overlap. One way to represent this with mathematics is to use two orthogonal vectors.\n\\begin{align*}\\cssId{ket0}{|0\\rangle} = \\begin{bmatrix} \\cssId{p0}{1} \\\\ \\cssId{p1}{0} \\end{bmatrix}, \\quad \\cssId{ket1}{|1\\rangle} =\\begin{bmatrix} \\cssId{p0}{0} \\\\ \\cssId{p1}{1} \\end{bmatrix}\\end{align*}\nThis is a lot of notation to take in all at once. First, let's unpack the weird | and \\rangle. Their job is essentially just to remind us that we are talking about the vectors that represent qubit states labelled 0 and 1. This helps us distinguish them from things like the bit values 0 and 1 or the numbers 0 and 1. It is part of the bra-ket notation, introduced by Dirac.\nIf you are not familiar with vectors, you can essentially just think of them as lists of numbers which we manipulate using certain rules. If you are familiar with vectors from your high school physics classes, you'll know that these rules make vectors well-suited for describing quantities with a magnitude and a direction. For example, the velocity of an object is described perfectly with a vector. However, the way we use vectors for quantum states is slightly different to this, so don't hold on too hard to your previous intuition. It's time to do something new!\nWith vectors we can describe more complex states than just |0\\rangle and |1\\rangle. For example, consider the vector\n\\begin{align*}\\cssId{q0}{|q_0\\rangle} = \\begin{bmatrix} \\cssId{p0}{\\tfrac{1}{\\sqrt{2}}} \\\\ \\cssId{p1}{\\tfrac{i}{\\sqrt{2}}} \\end{bmatrix}\\end{align*}\nTo understand what this state means, we'll need to use the mathematical rules for manipulating vectors. Specifically, we'll need to understand how to add vectors together and how to multiply them by scalars.\n\\begin{align*} |a\\rangle = \\begin{bmatrix}a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_n \\end{bmatrix}, \\quad |b\\rangle = \\begin{bmatrix}b_0 \\\\ b_1 \\\\ \\vdots \\\\ b_n \\end{bmatrix} \\end{align*}\n\\begin{align*} |a\\rangle + |b\\rangle = \\begin{bmatrix}a_0 + b_0 \\\\ a_1 + b_1 \\\\ \\vdots \\\\ a_n + b_n \\end{bmatrix} \\end{align*}\nAnd to multiply a vector by a scalar, we multiply each element by the scalar:\n\\begin{align*} x|a\\rangle = \\begin{bmatrix}x \\times a_0 \\\\ x \\times a_1 \\\\ \\vdots \\\\ x \\times a_n \\end{bmatrix} \\end{align*}\nThese two rules are used to rewrite the vector |q_0\\rangle (as shown above):\n\\begin{align*}\\begin{aligned} |q_0\\rangle &= \\tfrac{1}{\\sqrt{2}}|0\\rangle + \\tfrac{i}{\\sqrt{2}}|1\\rangle \\\\ &= \\tfrac{1}{\\sqrt{2}}\\begin{bmatrix}1 \\\\ 0\\end{bmatrix} + \\tfrac{i}{\\sqrt{2}}\\begin{bmatrix}0 \\\\ 1\\end{bmatrix} \\\\ &= \\begin{bmatrix}\\tfrac{1}{\\sqrt{2}} \\\\ 0\\end{bmatrix} + \\begin{bmatrix}0 \\\\ \\tfrac{i}{\\sqrt{2}}\\end{bmatrix} \\\\ &= \\begin{bmatrix}\\tfrac{1}{\\sqrt{2}} \\\\ \\tfrac{i}{\\sqrt{2}} \\end{bmatrix} \\\\ \\end{aligned}\\end{align*}\nAnd normalised means their magnitudes (length of the arrow) is equal to 1. The two vectors |0\\rangle and |1\\rangle are linearly independent, which means we cannot describe |0\\rangle in terms of |1\\rangle, and vice versa. However, using both the vectors |0\\rangle and |1\\rangle, and our rules of addition and multiplication by scalars, we can describe all possible vectors in 2D space:\nBecause the vectors |0\\rangle and |1\\rangle are linearly independent, and can be used to describe any vector in 2D space using vector addition and scalar multiplication, we say the vectors |0\\rangle and |1\\rangle form a basis. In this case, since they are both orthogonal and normalised, we call it an orthonormal basis.\nSince the states |0\\rangle and |1\\rangle form an orthonormal basis, we can represent any 2D vector with a combination of these two states. This allows us to write the state of our qubit in the alternative form:\n\\begin{align*} \\cssId{q0}{|q_0\\rangle} = \\cssId{term1}{\\tfrac{1}{\\sqrt{2}}|0\\rangle} + \\cssId{term2}{\\tfrac{i}{\\sqrt{2}}|1\\rangle} \\end{align*}\nThis vector, |q_0\\rangle is called the qubit's statevector, it tells us everything we could possibly know about this qubit. For now, we are only able to draw a few simple conclusions about this particular example of a statevector: it is not entirely |0\\rangle and not entirely |1\\rangle. Instead, it is described by a linear combination of the two. In quantum mechanics, we typically describe linear combinations such as this using the word 'superposition'.\nThough our example state |q_0\\rangle can be expressed as a superposition of |0\\rangle and |1\\rangle, it is no less a definite and well-defined qubit state than they are. To see this, we can begin to explore how a qubit can be manipulated.\nFirst, we need to import all the tools we will need:\nIn Qiskit, we use the QuantumCircuit object to store our circuits, this is essentially a list of the quantum operations on our circuit and the qubits they are applied to.\nIn our quantum circuits, our qubits always start out in the state |0\\rangle. We can use the initialize() method to transform this into any state. We give initialize() the vector we want in the form of a list, and tell it which qubit(s) we want to initialize in this state:\nWe can then use one of Qiskit\u2019s simulators to view the resulting state of our qubit.\nTo get the results from our circuit, we use run to execute our circuit, giving the circuit and the backend as arguments. We then use .result() to get the result of this:\nfrom result, we can then get the final statevector using .get_statevector():\nNote: Python uses j to represent i in complex numbers. We see a vector with two complex elements: 0.+0.j = 0, and 1.+0.j = 1.\nLet\u2019s now measure our qubit as we would in a real quantum computer and see the result:\nThis time, instead of the statevector we will get the counts for the 0 and 1 results using .get_counts():\nWe can see that we (unsurprisingly) have a % chance of measuring |1\\rangle.\nThis time, let\u2019s instead put our qubit into a superposition and see what happens. We will use the state |q_0\\rangle from earlier in this section:\n\\begin{align*} |q_0\\rangle = \\tfrac{1}{\\sqrt{2}}|0\\rangle + \\tfrac{\\cssId{i}{i}}{\\sqrt{2}}|1\\rangle \\end{align*}\nWe need to add these amplitudes to a python list. To add a complex amplitude, Python uses j for the imaginary unit (we normally call it \"i\" mathematically):\nAnd we then repeat the steps for initialising the qubit as before:\nWe can see we have equallessgreater probability of measuring |0\\rangle compared to |1\\rangle. To explain this, we need to talk about measurement.\nThere is a simple rule for measurement. To find the probability of measuring a state |\\psi \\rangle in the state |x\\rangle we do:\n\\begin{align*}p(|x\\rangle) = | \\langle x| \\psi \\rangle|^2\\end{align*}\nThe symbols \\langle and | tell us \\langle x | is a row vector. In quantum mechanics we call the column vectors kets and the row vectors bras. Together they make up bra-ket notation. Any ket |a\\rangle has a corresponding bra \\langle a|, and we convert between them using the conjugate transpose.\n\\begin{align*} \\quad|a\\rangle = \\begin{bmatrix}a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_n \\end{bmatrix} \\end{align*}\nTo get the conjugate transpose, the matrix is transposed and the elements are complex conjugated (represented by the \"\u2217\" operation) where complex conjugate of a complex number is a number with an equal real part and an imaginary part equal in magnitude but opposite in sign. This gives the corresponding bra (row vector) as follows:\n\\begin{align*} \\langle a| = \\begin{bmatrix}a_0^*, & a_1^*, & \\dots & a_n^* \\end{bmatrix} \\end{align*}\n\\begin{align*}\\langle a| = \\begin{bmatrix}a_0^*, & a_1^*, & \\dots & a_n^* \\end{bmatrix} \\end{align*}\n\\begin{align*}|b\\rangle = \\begin{bmatrix}b_0 \\\\ b_1 \\\\ \\vdots \\\\ b_n \\end{bmatrix} \\end{align*}\n\\begin{align*}\\langle a|b\\rangle = a_0^* b_0 + a_1^* b_1 \\dots a_n^* b_n \\end{align*}\nWe can see that the inner product of two vectors always gives us a scalar. A useful thing to remember is that the inner product of two orthogonal vectors is 0, for example if we have the orthogonal vectors |0\\rangle and |1\\rangle:\n\\begin{align*}\\langle1|0\\rangle = \\begin{bmatrix} 0 , & 1\\end{bmatrix}\\begin{bmatrix}1 \\\\ 0\\end{bmatrix} = 0\\end{align*}\nAdditionally, remember that the vectors |0\\rangle and |1\\rangle are also normalised (magnitudes are equal to 1):\n\\begin{align*}\\begin{aligned} \\langle0|0\\rangle &= \\begin{bmatrix} 1 , & 0\\end{bmatrix}\\begin{bmatrix}1 \\\\ 0\\end{bmatrix} = 1 \\\\ \\langle1|1\\rangle &= \\begin{bmatrix} 0 , & 1\\end{bmatrix}\\begin{bmatrix}0 \\\\ 1\\end{bmatrix} = 1 \\end{aligned}\\end{align*}\nIn the equation above, |x\\rangle can be any qubit state. To find the probability of measuring |x\\rangle, we take the inner product of |x\\rangle and the state we are measuring (in this case |\\psi\\rangle), then square the magnitude. This may seem a little convoluted, but it will soon become second nature.\nIf we look at the state |q_0\\rangle from before, we can see the probability of measuring |0\\rangle is indeed 0.5:\n\\begin{align*}\\begin{aligned} |q_0\\rangle & = \\tfrac{1}{\\sqrt{2}}|0\\rangle + \\tfrac{i}{\\sqrt{2}}|1\\rangle \\\\ \\langle 0| q_0 \\rangle & = \\tfrac{1}{\\sqrt{2}}\\langle 0|0\\rangle + \\tfrac{i}{\\sqrt{2}}\\langle 0|1\\rangle \\\\ & = \\tfrac{1}{\\sqrt{2}}\\cdot 1 + \\tfrac{i}{\\sqrt{2}} \\cdot 0\\\\ & = \\tfrac{1}{\\sqrt{2}}\\\\ |\\langle 0| q_0 \\rangle|^2 & = \\tfrac{1}{2} \\end{aligned}\\end{align*}\nYou should verify the probability of measuring |1\\rangle as an exercise.\nThis rule governs how we get information out of quantum states. It is therefore very important for everything we do in quantum computation. It also immediately implies several important facts.\nThe rule shows us that amplitudes are related to probabilities. If we want the probabilities to add up to 1 (which they should!), we need to ensure that the statevector is properly normalized. Specifically, we need the magnitude of the state vector to be 1.\n\\begin{align*} \\langle\\psi|\\psi\\rangle = 1 \\end{align*}\nThus if:\n\\begin{align*} |\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle \\end{align*}\nThen:\n\\begin{align*} |\\alpha|^2 + |\\beta|^2 = 1 \\end{align*}\nThis explains the factors of \\sqrt{2} you have seen throughout this chapter. In fact, if we try to give initialize() a vector that isn\u2019t normalised, it will give us an error:\nYou can check your answer in the widget below (accepts answers \u00b11% accuracy, you can use numpy terms such as 'pi' and 'sqrt()' in the vector):\nThe measurement rule gives us the probability p(|x\\rangle) that a state |\\psi\\rangle is measured as |x\\rangle. Nowhere does it tell us that |x\\rangle can only be either |0\\rangle or |1\\rangle.\nThe measurements we have considered so far are in fact only one of an infinite number of possible ways to measure a qubit. For any orthogonal pair of states, we can define a measurement that would cause a qubit to choose between the two.\nThis possibility will be explored more in the next section. For now, just bear in mind that |x\\rangle is not limited to being simply |0\\rangle or |1\\rangle.\nWe know that measuring the state |1\\rangle will give us the output 1 with certainty. But we are also able to write down states such as\n\\begin{align*}\\begin{bmatrix}0 \\\\ i\\end{bmatrix} = i|1\\rangle.\\end{align*}\nTo see how this behaves, we apply the measurement rule.\n\\begin{align*} |\\langle x| (i|1\\rangle) |^2 = | i \\langle x|1\\rangle|^2 = |\\langle x|1\\rangle|^2 \\end{align*}\nHere we find that the factor of i disappears once we take the magnitude of the complex number. This effect is completely independent of the measured state |x\\rangle. It does not matter what measurement we are considering, the probabilities for the state i|1\\rangle are identical to those for |1\\rangle. Since measurements are the only way we can extract any information from a qubit, this implies that these two states are equivalent in all ways that are physically relevant.\nMore generally, we refer to any overall factor \\gamma on a state for which |\\gamma|=1 as a 'global phase'. States that differ only by a global phase are physically indistinguishable.\n\\begin{align*} |\\langle x| ( \\gamma |a\\rangle) |^2 = | \\gamma \\langle x|a\\rangle|^2 = |\\langle x|a\\rangle|^2 \\end{align*}\nNote that this is distinct from the phase difference between terms in a superposition, which is known as the 'relative phase'. This becomes relevant once we consider different types of measurement and multiple qubits.\nWe know that the amplitudes contain information about the probability of us finding the qubit in a specific state, but once we have measured the qubit, we know with certainty what the state of the qubit is. For example, if we measure a qubit in the state:\n\\begin{align*} |q\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle\\end{align*}\nAnd find it in the state |0\\rangle, if we measure again, there is a 100% chance of finding the qubit in the state |0\\rangle. This means the act of measuring changes the state of our qubits.\n\\begin{align*} |q\\rangle = \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix} \\xrightarrow{\\text{Measure }|0\\rangle} |q\\rangle = |0\\rangle = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\\end{align*}\nWe sometimes refer to this as collapsing the state of the qubit. It is a potent effect, and so one that must be used wisely. For example, were we to constantly measure each of our qubits to keep track of their value at each point in a computation, they would always simply be in a well-defined state of either |0\\rangle or |1\\rangle. As such, they would be no different from classical bits and our computation could be easily replaced by a classical computation. To achieve truly quantum computation we must allow the qubits to explore more complex states. Measurements are therefore only used when we need to extract an output. This means that we often place all the measurements at the end of our quantum circuit.\nWe can demonstrate this using Qiskit\u2019s statevector simulator. Let's initialize a qubit in superposition:\nThis should initialize our qubit in the state:\n\\begin{align*} |q\\rangle = \\tfrac{i}{\\sqrt{2}}|0\\rangle + \\tfrac{1}{\\sqrt{2}}|1\\rangle \\end{align*}\nWe can verify this using the simulator:\nWe can see here the qubit is initialized in the state [0.+0.70710678j 0.70710678+0.j], which is the state we expected.\nLet\u2019s now create a circuit where we measure this qubit:\nWhen we simulate this entire circuit, we can see that one of the amplitudes is always 0:\nYou can re-run this cell a few times to reinitialize the qubit and measure it again. You will notice that either outcome is equally probable, but that the state of the qubit is never a superposition of |0\\rangle and |1\\rangle. Somewhat interestingly, the global phase on the state |0\\rangle survives, but since this is global phase, we can never measure it on a real quantum computer.\nWe can see that writing down a qubit\u2019s state requires keeping track of two complex numbers, but when using a real quantum computer we will only ever receive a yes-or-no (0 or 1) answer for each qubit. The output of a 10-qubit quantum computer will look like this:\n0110111110\nJust 10 bits, no superposition or complex amplitudes. When using a real quantum computer, we cannot see the states of our qubits mid-computation, as this would destroy them! This behaviour is not ideal for learning, so Qiskit provides different quantum simulators: By default, the aer_simulator mimics the execution of a real quantum computer, but will also allow you to peek at quantum states before measurement if we include certain instructions in our circuit. For example, here we have included the instruction .save_statevector(), which means we can use .get_statevector() on the result of the simulation.\nWe saw earlier in this chapter that the general state of a qubit (|q\\rangle) is:\n\\begin{align*}|q\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle\\end{align*}\n\\begin{align*}\\alpha, \\beta \\in \\mathbb{C}\\end{align*}\n(The second line tells us \\alpha and \\beta are complex numbers). The first two implications in section 2 tell us that we cannot differentiate between some of these states. This means we can be more specific in our description of the qubit.\nFirstly, since we cannot measure global phase, we can only measure the difference in phase between the states |0\\rangle and |1\\rangle. Instead of having \\alpha and \\beta be complex, we can confine them to the real numbers and add a term to tell us the relative phase between them:\n\\begin{align*}|q\\rangle = \\alpha|0\\rangle + e^{i\\phi}\\beta|1\\rangle\\end{align*}\n\\begin{align*}\\alpha, \\beta, \\phi \\in \\mathbb{R}\\end{align*}\nFinally, since the qubit state must be normalised, i.e.\n\\begin{align*}\\sqrt{\\alpha^2 + \\beta^2} = 1\\end{align*}\nwe can use the trigonometric identity:\n\\begin{align*}\\sqrt{\\sin^2{x} + \\cos^2{x}} = 1\\end{align*}\nto describe the real \\alpha and \\beta in terms of one variable, \\theta:\n\\begin{align*}\\alpha = \\cos{\\tfrac{\\theta}{2}}, \\quad \\beta=\\sin{\\tfrac{\\theta}{2}}\\end{align*}\nFrom this we can describe the state of any qubit using the two variables \\phi and \\theta:\n\\begin{align*}|q\\rangle = \\cos{\\tfrac{\\theta}{2}}|0\\rangle + e^{i\\phi}\\sin{\\tfrac{\\theta}{2}}|1\\rangle\\end{align*}\n\\begin{align*}\\theta, \\phi \\in \\mathbb{R}\\end{align*}\nWe want to plot our general qubit state:\n\\begin{align*}|q\\rangle = \\cos{\\tfrac{\\theta}{2}}|0\\rangle + e^{i\\phi}\\sin{\\tfrac{\\theta}{2}}|1\\rangle\\end{align*}\nIf we interpret \\theta and \\phi as spherical co-ordinates (r = 1, since the magnitude of the qubit state is 1), we can plot any single qubit state on the surface of a sphere, known as the Bloch sphere.\nBelow we have plotted a qubit in the state |{+}\\rangle. In this case, \\theta = \\pi/2 and \\phi = 0.\n(Qiskit has a function to plot a bloch sphere, plot_bloch_vector(), but at the time of writing it only takes cartesian coordinates. We have included a function that does the conversion automatically).\nYou can also try this interactive Bloch sphere demo.\nUse plot_bloch_vector() or plot_bloch_sphere_spherical() to plot a qubit in the states:\nWe have also included below a widget that converts from spherical co-ordinates to cartesian, for use with plot_bloch_vector():", "links": ["https://learn.qiskit.org/course/ch-states/representing-qubit-states", " https://learn.qiskit.org/course/ch-states/introduction", "https://en.wikipedia.org/course/ch-states/introduction", "https://en.wikipedia.org/course/ch-states/introduction", "https://en.wikipedia.org/course/ch-states/the-atoms-of-computation", "https://en.wikipedia.org/course/ch-states/the-atoms-of-computation", " https://learn.qiskit.org/course/ch-states/introduction#cvsq", " https://learn.qiskit.org/course/ch-states/introduction#statevectors", " https://learn.qiskit.org/course/ch-states/introduction#notation", " https://learn.qiskit.org/course/ch-states/introduction#exploring-qubits", " https://learn.qiskit.org/course/ch-states/introduction#rules-measurement", " https://learn.qiskit.org/course/ch-states/introduction#important-rule", " https://learn.qiskit.org/course/ch-states/introduction#implications", " https://learn.qiskit.org/course/ch-states/introduction#representing-30-19", " https://learn.qiskit.org/course/ch-states/introduction#representing-35-0", " https://learn.qiskit.org/course/ch-states/introduction#representing-36-0", " https://learn.qiskit.org/course/ch-states/introduction#representing-36-19", " https://learn.qiskit.org/course/ch-states/introduction#representing-44-2", " https://learn.qiskit.org/course/ch-states/introduction#bloch-sphere", " https://learn.qiskit.org/course/ch-states/introduction#bloch-sphere-1", " https://learn.qiskit.org/course/ch-states/introduction#bloch-sphere-2", "https://en.wikipedia.org/course/ch-states/single-qubit-gates", "https://en.wikipedia.org/course/ch-states/single-qubit-gates", "https://en.wikipedia.org/course/ch-states/the-case-for-quantum-computers", "https://en.wikipedia.org/course/ch-states/the-case-for-quantum-computers", "javascript:void(0)", "https://qiskit.org/learn", "javascript:void(0)", "https://en.wikipedia.org/v1/course/ch-states", "https://en.wikipedia.org/course/ch-appendix/an-introduction-to-linear-algebra-for-quantum-computing", "https://javafxpert.github.io/grok-bloch/", " https://learn.qiskit.org/course/ch-states/introduction#notation"]}, "Not Found": {"text": "/course/ch-states/representing-qubit-states\nWe could not find the above page on our servers.\nDid you mean: /wiki/course/ch-states/representing-qubit-states\nAlternatively, you can visit the Main Page or read more information about this type of error.", "links": ["https://en.wikipedia.org/course/ch-states/representing-qubit-states", "https://www.wikimedia.org", "https://en.wikipedia.org/wiki/course/ch-states/representing-qubit-states", "https://en.wikipedia.org/", "https://en.wikipedia.org/wiki/HTTP_404"]}, "Wikimedia": {"text": "Wikimedia is a global movement whose mission is to bring free educational content to the world.\nThrough various projects, chapters, and the support structure of the non-profit Wikimedia Foundation, Wikimedia strives to bring about a world in which every single human being can freely share in the sum of all knowledge.\nWelcome to Wikimedia.\nThis page is available under the Creative Commons Attribution-ShareAlike License\nTerms of Use\nPrivacy Policy", "links": ["https://www.wikimedia.org/", "https://meta.wikimedia.org/wiki/Special:MyLanguage/Wikimedia_movement", "https://meta.wikimedia.org/wiki/Our_projects", "https://meta.wikimedia.org/wiki/Special:MyLanguage/Wikimedia_chapters", "https://www.wikipedia.org/", "https://www.wiktionary.org/", "https://www.wikiquote.org/", "https://www.wikibooks.org/", "https://wikisource.org/", "https://www.wikinews.org/", "https://www.wikiversity.org/", "https://species.wikimedia.org/", "https://www.mediawiki.org/", "https://www.wikidata.org/", "https://commons.wikimedia.org/", "https://www.wikivoyage.org/", "https://meta.wikimedia.org/", "https://incubator.wikimedia.org/", "https://wikitech.wikimedia.org/", "https://wikitech.wikimedia.org/", "https://wikimediafoundation.org/", "https://creativecommons.org/licenses/by-sa/3.0/", "https://meta.wikimedia.org/wiki/Terms_of_use", "https://meta.wikimedia.org/wiki/Privacy_policy"]}}